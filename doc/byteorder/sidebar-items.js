initSidebarItems({"enum":[["BigEndian","Defines big-endian serialization.Note that this type has no value constructor. It is used purely at the type level."],["Error","An error type for reading bytes.This is a thin wrapper over the standard `io::Error` type. Namely, it adds one additional error case: an unexpected EOF.Note that this error is also used for the `write` methods to keep things consistent."],["LittleEndian","Defines little-endian serialization.Note that this type has no value constructor. It is used purely at the type level."]],"trait":[["ByteOrder","ByteOrder describes types that can serialize integers as bytes.Note that `Self` does not appear anywhere in this trait's definition! Therefore, in order to use it, you'll need to use syntax like `T::read_u16(&[0, 1])` where `T` implements `ByteOrder`.This crate provides two types that implement `ByteOrder`: `BigEndian` and `LittleEndian`.ExamplesWrite and read `u32` numbers in little endian order:Write and read `i16` numbers in big endian order:"],["ReadBytesExt","Extends `Read` with methods for reading numbers. (For `std::io`.)Most of the methods defined here have an unconstrained type parameter that must be explicitly instantiated. Typically, it is instantiated with either the `BigEndian` or `LittleEndian` types defined in this crate.ExamplesRead unsigned 16 bit big-endian integers from a `Read`:"],["WriteBytesExt","Extends `Write` with methods for writing numbers. (For `std::io`.)Most of the methods defined here have an unconstrained type parameter that must be explicitly instantiated. Typically, it is instantiated with either the `BigEndian` or `LittleEndian` types defined in this crate.ExamplesWrite unsigned 16 bit big-endian integers to a `Write`:"]],"type":[["NativeEndian","Defines system native-endian serialization.Note that this type has no value constructor. It is used purely at the type level."],["Result","A short-hand for `result::Result<T, byteorder::Error>`."]]});